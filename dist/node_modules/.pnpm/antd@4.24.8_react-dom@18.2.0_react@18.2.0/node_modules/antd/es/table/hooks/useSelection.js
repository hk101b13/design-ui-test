import _defineProperty from "../../../../../../@babel_runtime@7.23.6/node_modules/@babel/runtime/helpers/esm/defineProperty.js";
import _toArray from "../../../../../../@babel_runtime@7.23.6/node_modules/@babel/runtime/helpers/esm/toArray.js";
import _extends from "../../../../../../@babel_runtime@7.23.6/node_modules/@babel/runtime/helpers/esm/extends.js";
import _slicedToArray from "../../../../../../@babel_runtime@7.23.6/node_modules/@babel/runtime/helpers/esm/slicedToArray.js";
import _toConsumableArray from "../../../../../../@babel_runtime@7.23.6/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js";
import _typeof from "../../../../../../@babel_runtime@7.23.6/node_modules/@babel/runtime/helpers/esm/typeof.js";
import DownOutlined from "../../../../../../@ant-design_icons@4.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/es/icons/DownOutlined.js";
import "../../../../../../rc-table@7.26.0_react-dom@18.2.0_react@18.2.0/node_modules/rc-table/es/Table.js";
import * as React from "react";
import { useCallback, useMemo, useState } from "react";
import "../../../../../../rc-table@7.26.0_react-dom@18.2.0_react@18.2.0/node_modules/rc-table/es/Footer/Summary.js";
import { INTERNAL_COL_DEFINE } from "../../../../../../rc-table@7.26.0_react-dom@18.2.0_react@18.2.0/node_modules/rc-table/es/utils/legacyUtil.js";
import { arrDel, arrAdd } from "../../../../../../rc-tree@5.7.12_react-dom@18.2.0_react@18.2.0/node_modules/rc-tree/es/util.js";
import { conductCheck } from "../../../../../../rc-tree@5.7.12_react-dom@18.2.0_react@18.2.0/node_modules/rc-tree/es/utils/conductUtil.js";
import { convertDataToEntities } from "../../../../../../rc-tree@5.7.12_react-dom@18.2.0_react@18.2.0/node_modules/rc-tree/es/utils/treeUtil.js";
import useMergedState from "../../../../../../rc-util@5.38.1_react-dom@18.2.0_react@18.2.0/node_modules/rc-util/es/hooks/useMergedState.js";
import Checkbox from "../../checkbox/index.js";
import Dropdown from "../../dropdown/dropdown.js";
import Radio from "../../radio/index.js";
import warning from "../../_util/warning.js";
var SELECTION_COLUMN = {};
var SELECTION_ALL = "SELECT_ALL";
var SELECTION_INVERT = "SELECT_INVERT";
var SELECTION_NONE = "SELECT_NONE";
var EMPTY_LIST = [];
function flattenData(data, childrenColumnName) {
  var list = [];
  (data || []).forEach(function(record) {
    list.push(record);
    if (record && _typeof(record) === "object" && childrenColumnName in record) {
      list = [].concat(_toConsumableArray(list), _toConsumableArray(flattenData(record[childrenColumnName], childrenColumnName)));
    }
  });
  return list;
}
function useSelection(rowSelection, config) {
  var _ref = rowSelection || {}, preserveSelectedRowKeys = _ref.preserveSelectedRowKeys, selectedRowKeys = _ref.selectedRowKeys, defaultSelectedRowKeys = _ref.defaultSelectedRowKeys, getCheckboxProps = _ref.getCheckboxProps, onSelectionChange = _ref.onChange, onSelect = _ref.onSelect, onSelectAll = _ref.onSelectAll, onSelectInvert = _ref.onSelectInvert, onSelectNone = _ref.onSelectNone, onSelectMultiple = _ref.onSelectMultiple, selectionColWidth = _ref.columnWidth, selectionType = _ref.type, selections = _ref.selections, fixed = _ref.fixed, customizeRenderCell = _ref.renderCell, hideSelectAll = _ref.hideSelectAll, _ref$checkStrictly = _ref.checkStrictly, checkStrictly = _ref$checkStrictly === void 0 ? true : _ref$checkStrictly;
  var prefixCls = config.prefixCls, data = config.data, pageData = config.pageData, getRecordByKey = config.getRecordByKey, getRowKey = config.getRowKey, expandType = config.expandType, childrenColumnName = config.childrenColumnName, tableLocale = config.locale, getPopupContainer = config.getPopupContainer;
  var _useMergedState = useMergedState(selectedRowKeys || defaultSelectedRowKeys || EMPTY_LIST, {
    value: selectedRowKeys
  }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedSelectedKeys = _useMergedState2[0], setMergedSelectedKeys = _useMergedState2[1];
  var preserveRecordsRef = React.useRef(/* @__PURE__ */ new Map());
  var updatePreserveRecordsCache = useCallback(function(keys) {
    if (preserveSelectedRowKeys) {
      var newCache = /* @__PURE__ */ new Map();
      keys.forEach(function(key) {
        var record = getRecordByKey(key);
        if (!record && preserveRecordsRef.current.has(key)) {
          record = preserveRecordsRef.current.get(key);
        }
        newCache.set(key, record);
      });
      preserveRecordsRef.current = newCache;
    }
  }, [getRecordByKey, preserveSelectedRowKeys]);
  React.useEffect(function() {
    updatePreserveRecordsCache(mergedSelectedKeys);
  }, [mergedSelectedKeys]);
  var _useMemo = useMemo(function() {
    return checkStrictly ? {
      keyEntities: null
    } : convertDataToEntities(data, {
      externalGetKey: getRowKey,
      childrenPropName: childrenColumnName
    });
  }, [data, getRowKey, checkStrictly, childrenColumnName]), keyEntities = _useMemo.keyEntities;
  var flattedData = useMemo(function() {
    return flattenData(pageData, childrenColumnName);
  }, [pageData, childrenColumnName]);
  var checkboxPropsMap = useMemo(function() {
    var map = /* @__PURE__ */ new Map();
    flattedData.forEach(function(record, index) {
      var key = getRowKey(record, index);
      var checkboxProps = (getCheckboxProps ? getCheckboxProps(record) : null) || {};
      map.set(key, checkboxProps);
      process.env.NODE_ENV !== "production" ? warning(!("checked" in checkboxProps || "defaultChecked" in checkboxProps), "Table", "Do not set `checked` or `defaultChecked` in `getCheckboxProps`. Please use `selectedRowKeys` instead.") : void 0;
    });
    return map;
  }, [flattedData, getRowKey, getCheckboxProps]);
  var isCheckboxDisabled = useCallback(function(r) {
    var _a;
    return !!((_a = checkboxPropsMap.get(getRowKey(r))) === null || _a === void 0 ? void 0 : _a.disabled);
  }, [checkboxPropsMap, getRowKey]);
  var _useMemo2 = useMemo(function() {
    if (checkStrictly) {
      return [mergedSelectedKeys || [], []];
    }
    var _conductCheck = conductCheck(mergedSelectedKeys, true, keyEntities, isCheckboxDisabled), checkedKeys = _conductCheck.checkedKeys, halfCheckedKeys = _conductCheck.halfCheckedKeys;
    return [checkedKeys || [], halfCheckedKeys];
  }, [mergedSelectedKeys, checkStrictly, keyEntities, isCheckboxDisabled]), _useMemo3 = _slicedToArray(_useMemo2, 2), derivedSelectedKeys = _useMemo3[0], derivedHalfSelectedKeys = _useMemo3[1];
  var derivedSelectedKeySet = useMemo(function() {
    var keys = selectionType === "radio" ? derivedSelectedKeys.slice(0, 1) : derivedSelectedKeys;
    return new Set(keys);
  }, [derivedSelectedKeys, selectionType]);
  var derivedHalfSelectedKeySet = useMemo(function() {
    return selectionType === "radio" ? /* @__PURE__ */ new Set() : new Set(derivedHalfSelectedKeys);
  }, [derivedHalfSelectedKeys, selectionType]);
  var _useState = useState(null), _useState2 = _slicedToArray(_useState, 2), lastSelectedKey = _useState2[0], setLastSelectedKey = _useState2[1];
  React.useEffect(function() {
    if (!rowSelection) {
      setMergedSelectedKeys(EMPTY_LIST);
    }
  }, [!!rowSelection]);
  var setSelectedKeys = useCallback(function(keys, method) {
    var availableKeys;
    var records;
    updatePreserveRecordsCache(keys);
    if (preserveSelectedRowKeys) {
      availableKeys = keys;
      records = keys.map(function(key) {
        return preserveRecordsRef.current.get(key);
      });
    } else {
      availableKeys = [];
      records = [];
      keys.forEach(function(key) {
        var record = getRecordByKey(key);
        if (record !== void 0) {
          availableKeys.push(key);
          records.push(record);
        }
      });
    }
    setMergedSelectedKeys(availableKeys);
    onSelectionChange === null || onSelectionChange === void 0 ? void 0 : onSelectionChange(availableKeys, records, {
      type: method
    });
  }, [setMergedSelectedKeys, getRecordByKey, onSelectionChange, preserveSelectedRowKeys]);
  var triggerSingleSelection = useCallback(function(key, selected, keys, event) {
    if (onSelect) {
      var rows = keys.map(function(k) {
        return getRecordByKey(k);
      });
      onSelect(getRecordByKey(key), selected, rows, event);
    }
    setSelectedKeys(keys, "single");
  }, [onSelect, getRecordByKey, setSelectedKeys]);
  var mergedSelections = useMemo(function() {
    if (!selections || hideSelectAll) {
      return null;
    }
    var selectionList = selections === true ? [SELECTION_ALL, SELECTION_INVERT, SELECTION_NONE] : selections;
    return selectionList.map(function(selection) {
      if (selection === SELECTION_ALL) {
        return {
          key: "all",
          text: tableLocale.selectionAll,
          onSelect: function onSelect2() {
            setSelectedKeys(data.map(function(record, index) {
              return getRowKey(record, index);
            }).filter(function(key) {
              var checkProps = checkboxPropsMap.get(key);
              return !(checkProps === null || checkProps === void 0 ? void 0 : checkProps.disabled) || derivedSelectedKeySet.has(key);
            }), "all");
          }
        };
      }
      if (selection === SELECTION_INVERT) {
        return {
          key: "invert",
          text: tableLocale.selectInvert,
          onSelect: function onSelect2() {
            var keySet = new Set(derivedSelectedKeySet);
            pageData.forEach(function(record, index) {
              var key = getRowKey(record, index);
              var checkProps = checkboxPropsMap.get(key);
              if (!(checkProps === null || checkProps === void 0 ? void 0 : checkProps.disabled)) {
                if (keySet.has(key)) {
                  keySet["delete"](key);
                } else {
                  keySet.add(key);
                }
              }
            });
            var keys = Array.from(keySet);
            if (onSelectInvert) {
              process.env.NODE_ENV !== "production" ? warning(false, "Table", "`onSelectInvert` will be removed in future. Please use `onChange` instead.") : void 0;
              onSelectInvert(keys);
            }
            setSelectedKeys(keys, "invert");
          }
        };
      }
      if (selection === SELECTION_NONE) {
        return {
          key: "none",
          text: tableLocale.selectNone,
          onSelect: function onSelect2() {
            onSelectNone === null || onSelectNone === void 0 ? void 0 : onSelectNone();
            setSelectedKeys(Array.from(derivedSelectedKeySet).filter(function(key) {
              var checkProps = checkboxPropsMap.get(key);
              return checkProps === null || checkProps === void 0 ? void 0 : checkProps.disabled;
            }), "none");
          }
        };
      }
      return selection;
    }).map(function(selection) {
      return _extends(_extends({}, selection), {
        onSelect: function onSelect2() {
          var _a2;
          var _a;
          for (var _len = arguments.length, rest = new Array(_len), _key = 0; _key < _len; _key++) {
            rest[_key] = arguments[_key];
          }
          (_a = selection.onSelect) === null || _a === void 0 ? void 0 : (_a2 = _a).call.apply(_a2, [selection].concat(rest));
          setLastSelectedKey(null);
        }
      });
    });
  }, [selections, derivedSelectedKeySet, pageData, getRowKey, onSelectInvert, setSelectedKeys]);
  var transformColumns = useCallback(function(columns) {
    var _a;
    if (!rowSelection) {
      process.env.NODE_ENV !== "production" ? warning(!columns.includes(SELECTION_COLUMN), "Table", "`rowSelection` is not config but `SELECTION_COLUMN` exists in the `columns`.") : void 0;
      return columns.filter(function(col) {
        return col !== SELECTION_COLUMN;
      });
    }
    var cloneColumns = _toConsumableArray(columns);
    var keySet = new Set(derivedSelectedKeySet);
    var recordKeys = flattedData.map(getRowKey).filter(function(key) {
      return !checkboxPropsMap.get(key).disabled;
    });
    var checkedCurrentAll = recordKeys.every(function(key) {
      return keySet.has(key);
    });
    var checkedCurrentSome = recordKeys.some(function(key) {
      return keySet.has(key);
    });
    var onSelectAllChange = function onSelectAllChange2() {
      var changeKeys = [];
      if (checkedCurrentAll) {
        recordKeys.forEach(function(key) {
          keySet["delete"](key);
          changeKeys.push(key);
        });
      } else {
        recordKeys.forEach(function(key) {
          if (!keySet.has(key)) {
            keySet.add(key);
            changeKeys.push(key);
          }
        });
      }
      var keys = Array.from(keySet);
      onSelectAll === null || onSelectAll === void 0 ? void 0 : onSelectAll(!checkedCurrentAll, keys.map(function(k) {
        return getRecordByKey(k);
      }), changeKeys.map(function(k) {
        return getRecordByKey(k);
      }));
      setSelectedKeys(keys, "all");
      setLastSelectedKey(null);
    };
    var title;
    if (selectionType !== "radio") {
      var customizeSelections;
      if (mergedSelections) {
        var menu = {
          getPopupContainer,
          items: mergedSelections.map(function(selection, index) {
            var key = selection.key, text = selection.text, onSelectionClick = selection.onSelect;
            return {
              key: key || index,
              onClick: function onClick() {
                onSelectionClick === null || onSelectionClick === void 0 ? void 0 : onSelectionClick(recordKeys);
              },
              label: text
            };
          })
        };
        customizeSelections = /* @__PURE__ */ React.createElement("div", {
          className: "".concat(prefixCls, "-selection-extra")
        }, /* @__PURE__ */ React.createElement(Dropdown, {
          menu,
          getPopupContainer
        }, /* @__PURE__ */ React.createElement("span", null, /* @__PURE__ */ React.createElement(DownOutlined, null))));
      }
      var allDisabledData = flattedData.map(function(record, index) {
        var key = getRowKey(record, index);
        var checkboxProps = checkboxPropsMap.get(key) || {};
        return _extends({
          checked: keySet.has(key)
        }, checkboxProps);
      }).filter(function(_ref2) {
        var disabled = _ref2.disabled;
        return disabled;
      });
      var allDisabled = !!allDisabledData.length && allDisabledData.length === flattedData.length;
      var allDisabledAndChecked = allDisabled && allDisabledData.every(function(_ref3) {
        var checked = _ref3.checked;
        return checked;
      });
      var allDisabledSomeChecked = allDisabled && allDisabledData.some(function(_ref4) {
        var checked = _ref4.checked;
        return checked;
      });
      title = !hideSelectAll && /* @__PURE__ */ React.createElement("div", {
        className: "".concat(prefixCls, "-selection")
      }, /* @__PURE__ */ React.createElement(Checkbox, {
        checked: !allDisabled ? !!flattedData.length && checkedCurrentAll : allDisabledAndChecked,
        indeterminate: !allDisabled ? !checkedCurrentAll && checkedCurrentSome : !allDisabledAndChecked && allDisabledSomeChecked,
        onChange: onSelectAllChange,
        disabled: flattedData.length === 0 || allDisabled,
        "aria-label": customizeSelections ? "Custom selection" : "Select all",
        skipGroup: true
      }), customizeSelections);
    }
    var renderCell;
    if (selectionType === "radio") {
      renderCell = function renderCell2(_, record, index) {
        var key = getRowKey(record, index);
        var checked = keySet.has(key);
        return {
          node: /* @__PURE__ */ React.createElement(Radio, _extends({}, checkboxPropsMap.get(key), {
            checked,
            onClick: function onClick(e) {
              return e.stopPropagation();
            },
            onChange: function onChange(event) {
              if (!keySet.has(key)) {
                triggerSingleSelection(key, true, [key], event.nativeEvent);
              }
            }
          })),
          checked
        };
      };
    } else {
      renderCell = function renderCell2(_, record, index) {
        var _a2;
        var key = getRowKey(record, index);
        var checked = keySet.has(key);
        var indeterminate = derivedHalfSelectedKeySet.has(key);
        var checkboxProps = checkboxPropsMap.get(key);
        var mergedIndeterminate;
        if (expandType === "nest") {
          mergedIndeterminate = indeterminate;
          process.env.NODE_ENV !== "production" ? warning(typeof (checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.indeterminate) !== "boolean", "Table", "set `indeterminate` using `rowSelection.getCheckboxProps` is not allowed with tree structured dataSource.") : void 0;
        } else {
          mergedIndeterminate = (_a2 = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.indeterminate) !== null && _a2 !== void 0 ? _a2 : indeterminate;
        }
        return {
          node: /* @__PURE__ */ React.createElement(Checkbox, _extends({}, checkboxProps, {
            indeterminate: mergedIndeterminate,
            checked,
            skipGroup: true,
            onClick: function onClick(e) {
              return e.stopPropagation();
            },
            onChange: function onChange(_ref5) {
              var nativeEvent = _ref5.nativeEvent;
              var shiftKey = nativeEvent.shiftKey;
              var startIndex = -1;
              var endIndex = -1;
              if (shiftKey && checkStrictly) {
                var pointKeys = /* @__PURE__ */ new Set([lastSelectedKey, key]);
                recordKeys.some(function(recordKey, recordIndex) {
                  if (pointKeys.has(recordKey)) {
                    if (startIndex === -1) {
                      startIndex = recordIndex;
                    } else {
                      endIndex = recordIndex;
                      return true;
                    }
                  }
                  return false;
                });
              }
              if (endIndex !== -1 && startIndex !== endIndex && checkStrictly) {
                var rangeKeys = recordKeys.slice(startIndex, endIndex + 1);
                var changedKeys = [];
                if (checked) {
                  rangeKeys.forEach(function(recordKey) {
                    if (keySet.has(recordKey)) {
                      changedKeys.push(recordKey);
                      keySet["delete"](recordKey);
                    }
                  });
                } else {
                  rangeKeys.forEach(function(recordKey) {
                    if (!keySet.has(recordKey)) {
                      changedKeys.push(recordKey);
                      keySet.add(recordKey);
                    }
                  });
                }
                var keys = Array.from(keySet);
                onSelectMultiple === null || onSelectMultiple === void 0 ? void 0 : onSelectMultiple(!checked, keys.map(function(recordKey) {
                  return getRecordByKey(recordKey);
                }), changedKeys.map(function(recordKey) {
                  return getRecordByKey(recordKey);
                }));
                setSelectedKeys(keys, "multiple");
              } else {
                var originCheckedKeys = derivedSelectedKeys;
                if (checkStrictly) {
                  var checkedKeys = checked ? arrDel(originCheckedKeys, key) : arrAdd(originCheckedKeys, key);
                  triggerSingleSelection(key, !checked, checkedKeys, nativeEvent);
                } else {
                  var result = conductCheck([].concat(_toConsumableArray(originCheckedKeys), [key]), true, keyEntities, isCheckboxDisabled);
                  var _checkedKeys = result.checkedKeys, halfCheckedKeys = result.halfCheckedKeys;
                  var nextCheckedKeys = _checkedKeys;
                  if (checked) {
                    var tempKeySet = new Set(_checkedKeys);
                    tempKeySet["delete"](key);
                    nextCheckedKeys = conductCheck(Array.from(tempKeySet), {
                      checked: false,
                      halfCheckedKeys
                    }, keyEntities, isCheckboxDisabled).checkedKeys;
                  }
                  triggerSingleSelection(key, !checked, nextCheckedKeys, nativeEvent);
                }
              }
              if (checked) {
                setLastSelectedKey(null);
              } else {
                setLastSelectedKey(key);
              }
            }
          })),
          checked
        };
      };
    }
    var renderSelectionCell = function renderSelectionCell2(_, record, index) {
      var _renderCell = renderCell(_, record, index), node = _renderCell.node, checked = _renderCell.checked;
      if (customizeRenderCell) {
        return customizeRenderCell(checked, record, index, node);
      }
      return node;
    };
    if (!cloneColumns.includes(SELECTION_COLUMN)) {
      if (cloneColumns.findIndex(function(col) {
        var _a2;
        return ((_a2 = col[INTERNAL_COL_DEFINE]) === null || _a2 === void 0 ? void 0 : _a2.columnType) === "EXPAND_COLUMN";
      }) === 0) {
        var _cloneColumns = cloneColumns, _cloneColumns2 = _toArray(_cloneColumns), expandColumn = _cloneColumns2[0], restColumns = _cloneColumns2.slice(1);
        cloneColumns = [expandColumn, SELECTION_COLUMN].concat(_toConsumableArray(restColumns));
      } else {
        cloneColumns = [SELECTION_COLUMN].concat(_toConsumableArray(cloneColumns));
      }
    }
    var selectionColumnIndex = cloneColumns.indexOf(SELECTION_COLUMN);
    process.env.NODE_ENV !== "production" ? warning(cloneColumns.filter(function(col) {
      return col === SELECTION_COLUMN;
    }).length <= 1, "Table", "Multiple `SELECTION_COLUMN` exist in `columns`.") : void 0;
    cloneColumns = cloneColumns.filter(function(column, index) {
      return column !== SELECTION_COLUMN || index === selectionColumnIndex;
    });
    var prevCol = cloneColumns[selectionColumnIndex - 1];
    var nextCol = cloneColumns[selectionColumnIndex + 1];
    var mergedFixed = fixed;
    if (mergedFixed === void 0) {
      if ((nextCol === null || nextCol === void 0 ? void 0 : nextCol.fixed) !== void 0) {
        mergedFixed = nextCol.fixed;
      } else if ((prevCol === null || prevCol === void 0 ? void 0 : prevCol.fixed) !== void 0) {
        mergedFixed = prevCol.fixed;
      }
    }
    if (mergedFixed && prevCol && ((_a = prevCol[INTERNAL_COL_DEFINE]) === null || _a === void 0 ? void 0 : _a.columnType) === "EXPAND_COLUMN" && prevCol.fixed === void 0) {
      prevCol.fixed = mergedFixed;
    }
    var selectionColumn = _defineProperty({
      fixed: mergedFixed,
      width: selectionColWidth,
      className: "".concat(prefixCls, "-selection-column"),
      title: rowSelection.columnTitle || title,
      render: renderSelectionCell
    }, INTERNAL_COL_DEFINE, {
      className: "".concat(prefixCls, "-selection-col")
    });
    return cloneColumns.map(function(col) {
      return col === SELECTION_COLUMN ? selectionColumn : col;
    });
  }, [getRowKey, flattedData, rowSelection, derivedSelectedKeys, derivedSelectedKeySet, derivedHalfSelectedKeySet, selectionColWidth, mergedSelections, expandType, lastSelectedKey, checkboxPropsMap, onSelectMultiple, triggerSingleSelection, isCheckboxDisabled]);
  return [transformColumns, derivedSelectedKeySet];
}
export {
  SELECTION_ALL,
  SELECTION_COLUMN,
  SELECTION_INVERT,
  SELECTION_NONE,
  useSelection as default
};
