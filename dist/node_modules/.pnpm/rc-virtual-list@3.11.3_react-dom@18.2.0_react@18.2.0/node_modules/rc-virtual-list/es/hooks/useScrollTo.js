import _typeof from "../../../../../@babel_runtime@7.23.6/node_modules/@babel/runtime/helpers/esm/typeof.js";
import _objectSpread2 from "../../../../../@babel_runtime@7.23.6/node_modules/@babel/runtime/helpers/esm/objectSpread2.js";
import _slicedToArray from "../../../../../@babel_runtime@7.23.6/node_modules/@babel/runtime/helpers/esm/slicedToArray.js";
import * as React from "react";
import raf from "../../../../../rc-util@5.38.1_react-dom@18.2.0_react@18.2.0/node_modules/rc-util/es/raf.js";
import useLayoutEffect from "../../../../../rc-util@5.38.1_react-dom@18.2.0_react@18.2.0/node_modules/rc-util/es/hooks/useLayoutEffect.js";
import "../../../../../react-is@18.2.0/node_modules/react-is/index.js";
import { warningOnce } from "../../../../../rc-util@5.38.1_react-dom@18.2.0_react@18.2.0/node_modules/rc-util/es/warning.js";
var MAX_TIMES = 10;
function useScrollTo(containerRef, data, heights, itemHeight, getKey, collectHeight, syncScrollTop, triggerFlash) {
  var scrollRef = React.useRef();
  var _React$useState = React.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), syncState = _React$useState2[0], setSyncState = _React$useState2[1];
  useLayoutEffect(function() {
    if (syncState && syncState.times < MAX_TIMES) {
      if (!containerRef.current) {
        setSyncState(function(ori) {
          return _objectSpread2({}, ori);
        });
        return;
      }
      collectHeight();
      var targetAlign = syncState.targetAlign, originAlign = syncState.originAlign, index = syncState.index, offset = syncState.offset;
      var height = containerRef.current.clientHeight;
      var needCollectHeight = false;
      var newTargetAlign = targetAlign;
      var targetTop = null;
      if (height) {
        var mergedAlign = targetAlign || originAlign;
        var stackTop = 0;
        var itemTop = 0;
        var itemBottom = 0;
        var maxLen = Math.min(data.length - 1, index);
        for (var i = 0; i <= maxLen; i += 1) {
          var key = getKey(data[i]);
          itemTop = stackTop;
          var cacheHeight = heights.get(key);
          itemBottom = itemTop + (cacheHeight === void 0 ? itemHeight : cacheHeight);
          stackTop = itemBottom;
        }
        var leftHeight = mergedAlign === "top" ? offset : height - offset;
        for (var _i = maxLen; _i >= 0; _i -= 1) {
          var _key = getKey(data[_i]);
          var _cacheHeight = heights.get(_key);
          if (_cacheHeight === void 0) {
            needCollectHeight = true;
            break;
          }
          leftHeight -= _cacheHeight;
          if (leftHeight <= 0) {
            break;
          }
        }
        switch (mergedAlign) {
          case "top":
            targetTop = itemTop - offset;
            break;
          case "bottom":
            targetTop = itemBottom - height + offset;
            break;
          default: {
            var scrollTop = containerRef.current.scrollTop;
            var scrollBottom = scrollTop + height;
            if (itemTop < scrollTop) {
              newTargetAlign = "top";
            } else if (itemBottom > scrollBottom) {
              newTargetAlign = "bottom";
            }
          }
        }
        if (targetTop !== null) {
          syncScrollTop(targetTop);
        }
        if (targetTop !== syncState.lastTop) {
          needCollectHeight = true;
        }
      }
      if (needCollectHeight) {
        setSyncState(_objectSpread2(_objectSpread2({}, syncState), {}, {
          times: syncState.times + 1,
          targetAlign: newTargetAlign,
          lastTop: targetTop
        }));
      }
    } else if (process.env.NODE_ENV !== "production" && (syncState === null || syncState === void 0 ? void 0 : syncState.times) === MAX_TIMES) {
      warningOnce(false, "Seems `scrollTo` with `rc-virtual-list` reach the max limitation. Please fire issue for us. Thanks.");
    }
  }, [syncState, containerRef.current]);
  return function(arg) {
    if (arg === null || arg === void 0) {
      triggerFlash();
      return;
    }
    raf.cancel(scrollRef.current);
    if (typeof arg === "number") {
      syncScrollTop(arg);
    } else if (arg && _typeof(arg) === "object") {
      var index;
      var align = arg.align;
      if ("index" in arg) {
        index = arg.index;
      } else {
        index = data.findIndex(function(item) {
          return getKey(item) === arg.key;
        });
      }
      var _arg$offset = arg.offset, offset = _arg$offset === void 0 ? 0 : _arg$offset;
      setSyncState({
        times: 0,
        index,
        offset,
        originAlign: align
      });
    }
  };
}
export {
  useScrollTo as default
};
